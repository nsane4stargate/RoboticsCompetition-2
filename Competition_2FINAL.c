#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S4,     SONAR,          sensorEV3_Ultrasonic)
#pragma config(Motor,  motorB,          LEFT,          tmotorEV3_Large, PIDControl, reversed, driveLeft, encoder)
#pragma config(Motor,  motorC,          RIGHT,         tmotorEV3_Large, PIDControl, reversed, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*This program allows the robot to find the center of a rectange.
 *It first scans an area to find the closest wall. Once the closet
 *wall is found, it than executes the remaining program. It finds
 *the length of one wall and move to the center of that measurement.
 *It then take measurements of another wall perpendicular to the first,
 *and moves to the center of the second wall.
*/
int k = 2, desiredPower, maxPower =  20;
long currentPower;
float currentDistance = 0, error, desiredAngle, currentAngle = 0, nTurnRatio = 0, wallLeftDistance, wallRightDistance,wallTotalLength,desiredDistance = 25, startAngle, startDistance;

float tolerance = 1, maxDistance = 250; // 2 cm
int slewRate = 5, centerDistanceCounts = 0;



void slewRateAngleControl(){

repeatUntil(currentAngle == desiredAngle){

			error = desiredAngle - currentAngle;

			if (abs(error) > tolerance){
				desiredPower = (k * error); // if we are outside the tolerance range, we want to move
				if(currentPower < desiredPower){
					if(currentPower + slewRate < desiredPower)
							currentPower += slewRate;
					else
							currentPower = desiredPower;
							if(currentPower > maxPower)
								currentPower = maxPower;
				}
				else if(currentPower > desiredPower){
					if(currentPower - slewRate > desiredPower)
							currentPower -= slewRate;
					else
							currentPower = desiredPower;
							if(currentPower < -(maxPower))
								currentPower = - maxPower;
					}
				}
			currentAngle = -getGyroDegrees(gyroSensor);
		}// END OF repeatUntil()

		currentPower = 0;
		resetGyro(gyroSensor);
		nTurnRatio = 0;
}// END OF slewRatecontrol()

void goToStartAngle(){
		nTurnRatio = -100;
		desiredAngle = startAngle;

		// Turn to startAngle:
		slewRateAngleControl();
}// END OF goToStartAngle()

void getStartPos(){

		desiredAngle = ((2*PI)*(180/PI));
		nTurnRatio = -100;
		startDistance = currentDistance;

		repeatUntil(currentAngle == desiredAngle){

			error = desiredAngle - currentAngle;

			if (abs(error) > tolerance){
				desiredPower = (k * error); // if we are outside the tolerance range, we want to move
				if(currentPower < desiredPower){
					if(currentPower + slewRate < desiredPower)
							currentPower += slewRate;
					else
							currentPower = desiredPower;
							if(currentPower > maxPower)
								currentPower = maxPower;
				}
				else if(currentPower > desiredPower){
					if(currentPower - slewRate > desiredPower)
							currentPower -= slewRate;
					else
							currentPower = desiredPower;
							if(currentPower < -(maxPower))
								currentPower = - maxPower;
					}
				}
			currentAngle = -getGyroDegrees(gyroSensor);
			if(currentDistance < startDistance){
				  startDistance = currentDistance;
				  startAngle = currentAngle;
			}
			setMotorSync(RIGHT, LEFT, nTurnRatio, currentPower); // move the motors
		}// END OF repeatUntil()

		currentPower = 0;
		nTurnRatio = 0;
		resetGyro(gyroSensor);
		goToStartAngle();
}// END OF getStartPos()

void leftTurn(){

		desiredAngle = ((PI)*(180/PI));
		nTurnRatio = -100;

		// Turn Left
		slewRateAngleControl();
}// END OF leftTurn()

void rightTurn(){

		desiredAngle = -((PI)*(180/PI));
		nTurnRatio = -100;

		// Turn Right
		slewRateAngleControl();
}// END OF rightTurn()


void wallTurnDetection(){

		desiredAngle = ((PI/2)*(180/PI));
		nTurnRatio = -100;

		//Turn left to test the how far a wall is
		slewRateAngleControl();

		currentPower = 0;
		wallLeftDistance = getUSDistance(SONAR);
		sleep(500);

		resetGyro(gyroSensor);
		desiredAngle = -(PI*(180/PI));

		//Turn right to test the how far a wall is
		nTurnRatio = -100;
		slewRateAngleControl();

		currentPower = 0;
		wallRightDistance = getUSDistance(SONAR);

		sleep(500);
		resetGyro(gyroSensor);

		/* Store the total distance of the wallRightDistance and the
		 * wallLeftDistance
		 */
	 	wallTotalLength = wallRightDistance + wallLeftDistance;

		/* If the distance of the wall to the right is greater
		 * set the nTurnRatio = 0 to go straight towards the right wall;
		 * else turn left by calling the leftTurn()
		 */
		if(wallRightDistance > wallLeftDistance){
      	nTurnRatio = 0;
			}else{
				leftTurn();
			}
		/* If the distance of the wall to the left is greater
		 * set the nTurnRatio = 0 to go straight towards the left wall;
		 * else turn right by calling the rightTurn()
		 */
		if(wallLeftDistance > wallRightDistance){
				nTurnRatio = 0;
		}else{
				rightTurn();
		}
		desiredDistance = maxDistance = (wallTotalLength / 2);
}// END OF wallTurnDetection()


// Task to read range sensor
task readDistanceTask()
{
	while(true)
	{
		currentDistance = getUSDistance(SONAR);
		displayCenteredBigTextLine(0, "CD: %.2f cm",currentDistance);
		displayCenteredBigTextLine(3, "DD: %.2f cm",desiredDistance);
		displayCenteredBigTextLine(5, "MD: %.2f cm",maxDistance);
		sleep(10);
	}
}// END OF readDistanceTask()

task controllerTask()
{
	while(true){


		// Calculates error for later use when calculating desiredPower
		error = desiredDistance - currentDistance;

		/* If error is greater than the tolerance, calculate the desired power,
		 * else stop and detect the wall distances if the counter is less than 3
		 */
		if(abs(error) > tolerance){
				desiredPower = k * error; // if we are outside the tolerance range, we want to adjust speed
			}else{
				centerDistanceCounts ++;
				currentPower = desiredPower = 0;

				if(centerDistanceCounts == 3){
						stopAllTasks();
					}

				wallTurnDetection();
			}

		/* If robot is closer than the desiredDistance, it will reverse (-desiredPower) until it
		 * is within tolerance of the desiredDistance
		 */
		if(currentDistance < desiredDistance){
			if(currentPower + slewRate < -(desiredPower)){
				currentPower += slewRate;
				}else{
				if(currentPower - slewRate > -(desiredPower))
					currentPower -= slewRate;
			}
		}// end of if-else(currentDistance < desiredDistance)

		/* If robot is less the desiredDistance, it will move forward
		 * by desiredPower until it is within tolerance
		 */
		else if(currentDistance > desiredDistance){
			if(currentPower + slewRate < -(desiredPower)){
				currentPower += slewRate;
				}else{
				if(currentPower - slewRate > -(desiredPower))
					currentPower -= slewRate;
				}
		}// END OF IF - ELSEIF STATEMENT
		sleep(100);
	}// END OF WHILE LOOP
}// END OF controllerTask()

task main(){
	sensorReset(SONAR);
	resetGyro(gyroSensor);
	startTask(readDistanceTask);
	getStartPos();
	startTask(controllerTask);
	while(true){
		setMotorSync(RIGHT, LEFT, nTurnRatio, currentPower); // move the motors
	}

}
